name: Deploy

on:
  push:
    branches:
      - main
      - stage
      - develop

jobs:
  deploy:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name == 'main' && 'prod' || github.ref_name == 'stage' && 'stage' || 'dev' }}
    env:
      DEPLOY_ENV: ${{ github.ref_name == 'main' && 'prod' || github.ref_name == 'stage' && 'stage' || 'dev' }}
      AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
      ECR_REPO: ${{ vars.ECR_REPO }}
      APP_RUNNER_SERVICE: ${{ vars.APP_RUNNER_SERVICE }}
      S3_BUCKET: ${{ vars.S3_BUCKET }}
      VITE_EXCEL_API_ENABLED: ${{ vars.VITE_EXCEL_API_ENABLED || 'true' }}
      VITE_DISABLE_AUTH: ${{ vars.VITE_DISABLE_AUTH || '' }}
      VITE_BACKEND_TARGET: ${{ vars.VITE_BACKEND_TARGET || 'legacy' }}
      VITE_APP_ENV: ${{ github.ref_name == 'main' && 'prod' || github.ref_name == 'stage' && 'stage' || 'dev' }}
      VITE_COGNITO_REGION: ${{ vars.VITE_COGNITO_REGION || '' }}
      VITE_COGNITO_CLIENT_ID: ${{ vars.VITE_COGNITO_CLIENT_ID || '' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify environment config
        run: |
          set -euo pipefail
          if [ -z "${ECR_REPO}" ]; then
            echo "ECR_REPO not set (use GitHub Environment vars)."
            exit 1
          fi
          if [ -z "${APP_RUNNER_SERVICE}" ]; then
            echo "APP_RUNNER_SERVICE not set (use GitHub Environment vars)."
            exit 1
          fi
          if [ -z "${S3_BUCKET}" ]; then
            echo "S3_BUCKET not set (will use Frontend stack output)."
          fi

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        run: |
          set -euo pipefail
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}"
          IMAGE_TAG="${GITHUB_SHA::7}"

          if ! aws ecr describe-repositories --repository-names "${ECR_REPO}" --region "${AWS_REGION}" >/dev/null 2>&1; then
            aws ecr create-repository --repository-name "${ECR_REPO}" --region "${AWS_REGION}" >/dev/null
          fi

          docker build -t "${ECR_REPO}:${IMAGE_TAG}" backend
          docker tag "${ECR_REPO}:${IMAGE_TAG}" "${ECR_URI}:${IMAGE_TAG}"
          docker tag "${ECR_REPO}:${IMAGE_TAG}" "${ECR_URI}:latest"
          docker push "${ECR_URI}:${IMAGE_TAG}"
          docker push "${ECR_URI}:latest"

      - name: Resolve App Runner URL
        run: |
          set -euo pipefail
          SERVICE_ARN=$(aws apprunner list-services --region "${AWS_REGION}" \
            --query "ServiceSummaryList[?ServiceName=='${APP_RUNNER_SERVICE}'].ServiceArn" \
            --output text)

          if [ -z "${SERVICE_ARN}" ] || [ "${SERVICE_ARN}" = "None" ]; then
            echo "App Runner service '${APP_RUNNER_SERVICE}' not found."
            exit 1
          fi

          BACKEND_URL=$(aws apprunner describe-service --service-arn "${SERVICE_ARN}" --region "${AWS_REGION}" \
            --query "Service.ServiceUrl" --output text)

          if [[ "${BACKEND_URL}" != http* ]]; then
            BACKEND_URL="https://${BACKEND_URL}"
          fi
          echo "BACKEND_URL=${BACKEND_URL%/}" >> $GITHUB_ENV

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: npm
          cache-dependency-path: |
            frontend/package-lock.json
            infra/package-lock.json

      - name: Deploy frontend infrastructure (CloudFront /api proxy)
        run: |
          set -euo pipefail
          API_DOMAIN="${BACKEND_URL#https://}"
          API_DOMAIN="${API_DOMAIN#http://}"
          API_DOMAIN="${API_DOMAIN%%/*}"
          SERVICE_ARN=$(aws apprunner list-services --region "${AWS_REGION}" \
            --query "ServiceSummaryList[?ServiceName=='${APP_RUNNER_SERVICE}'].ServiceArn" \
            --output text)
          if [ -z "${SERVICE_ARN}" ] || [ "${SERVICE_ARN}" = "None" ]; then
            echo "App Runner service '${APP_RUNNER_SERVICE}' not found."
            exit 1
          fi
          APP_RUNNER_ENV=$(aws apprunner describe-service --service-arn "${SERVICE_ARN}" --region "${AWS_REGION}" \
            --query "Service.SourceConfiguration.ImageRepository.ImageConfiguration.RuntimeEnvironmentVariables" --output json)
          cd infra
          npm ci
          npx cdk bootstrap
          BACKEND_LAMBDA_CONTEXT=$(jq -cn \
            --arg mode "fastapi" \
            --arg legacy "${BACKEND_URL}" \
            --arg region "${AWS_REGION}" \
            --argjson env "${APP_RUNNER_ENV}" \
            '{mode:$mode,legacyBackendUrl:$legacy,env:($env + {"AWS_REGION":$region})}')
          npx cdk deploy EstimationBackendLambdaStack --require-approval never -c backendLambda="${BACKEND_LAMBDA_CONTEXT}"
          NEXT_API_URL=$(aws cloudformation describe-stacks --stack-name EstimationBackendLambdaStack --region "${AWS_REGION}" \
            --query "Stacks[0].Outputs[?OutputKey=='BackendLambdaApiUrl'].OutputValue" --output text)
          if [ -n "${NEXT_API_URL}" ] && [ "${NEXT_API_URL}" != "None" ]; then
            FRONTEND_CONTEXT=$(printf '{"apiDomain":"%s","nextApiUrl":"%s"}' "${API_DOMAIN}" "${NEXT_API_URL}")
          else
            FRONTEND_CONTEXT=$(printf '{"apiDomain":"%s"}' "${API_DOMAIN}")
          fi
          npx cdk deploy EstimationFrontendStack --require-approval never -c frontend="${FRONTEND_CONTEXT}"
          FRONTEND_BUCKET=$(aws cloudformation describe-stacks --stack-name EstimationFrontendStack --region "${AWS_REGION}" \
            --query "Stacks[0].Outputs[?OutputKey=='FrontendBucketName'].OutputValue" --output text)
          FRONTEND_DISTRIBUTION_ID=$(aws cloudformation describe-stacks --stack-name EstimationFrontendStack --region "${AWS_REGION}" \
            --query "Stacks[0].Outputs[?OutputKey=='FrontendDistributionId'].OutputValue" --output text)
          FRONTEND_URL=$(aws cloudformation describe-stacks --stack-name EstimationFrontendStack --region "${AWS_REGION}" \
            --query "Stacks[0].Outputs[?OutputKey=='FrontendUrl'].OutputValue" --output text)
          if [ -n "${FRONTEND_BUCKET}" ] && [ "${FRONTEND_BUCKET}" != "None" ]; then
            echo "FRONTEND_BUCKET=${FRONTEND_BUCKET}" >> $GITHUB_ENV
          fi
          if [ -n "${FRONTEND_DISTRIBUTION_ID}" ] && [ "${FRONTEND_DISTRIBUTION_ID}" != "None" ]; then
            echo "FRONTEND_DISTRIBUTION_ID=${FRONTEND_DISTRIBUTION_ID}" >> $GITHUB_ENV
          fi
          if [ -n "${FRONTEND_URL}" ] && [ "${FRONTEND_URL}" != "None" ]; then
            echo "FRONTEND_URL=${FRONTEND_URL}" >> $GITHUB_ENV
          fi

      - name: Build frontend
        run: |
          set -euo pipefail
          cd frontend
          export VITE_API_URL="/"
          if [ -n "${VITE_EXCEL_API_ENABLED}" ]; then export VITE_EXCEL_API_ENABLED; fi
          if [ -n "${VITE_DISABLE_AUTH}" ]; then export VITE_DISABLE_AUTH; fi
          if [ -n "${VITE_BACKEND_TARGET}" ]; then export VITE_BACKEND_TARGET; fi
          if [ -n "${VITE_APP_ENV}" ]; then export VITE_APP_ENV; fi
          if [ -n "${VITE_COGNITO_REGION}" ]; then export VITE_COGNITO_REGION; fi
          if [ -n "${VITE_COGNITO_CLIENT_ID}" ]; then export VITE_COGNITO_CLIENT_ID; fi
          npm ci
          npm run build

      - name: Deploy frontend to S3
        run: |
          set -euo pipefail
          TARGET_BUCKET="${FRONTEND_BUCKET:-${S3_BUCKET}}"
          if [ -z "${TARGET_BUCKET}" ] || [ "${TARGET_BUCKET}" = "None" ]; then
            echo "No target S3 bucket resolved (set S3_BUCKET or use Frontend stack output)."
            exit 1
          fi
          aws s3 sync frontend/dist "s3://${TARGET_BUCKET}/" --delete --region "${AWS_REGION}"

      - name: Invalidate CloudFront cache
        run: |
          set -euo pipefail
          DISTRIBUTION_ID="${FRONTEND_DISTRIBUTION_ID:-}"
          if [ -z "${DISTRIBUTION_ID}" ] || [ "${DISTRIBUTION_ID}" = "None" ]; then
            DISTRIBUTION_ID=$(aws cloudformation describe-stacks --stack-name EstimationFrontendStack --region "${AWS_REGION}" \
              --query "Stacks[0].Outputs[?OutputKey=='FrontendDistributionId'].OutputValue" --output text)
          fi
          if [ -n "${DISTRIBUTION_ID}" ] && [ "${DISTRIBUTION_ID}" != "None" ]; then
            aws cloudfront create-invalidation --distribution-id "${DISTRIBUTION_ID}" --paths "/*" >/dev/null
          else
            echo "CloudFront distribution id not found; skipping invalidation."
          fi

      - name: Report frontend URL
        run: |
          if [ -n "${FRONTEND_URL}" ] && [ "${FRONTEND_URL}" != "None" ]; then
            echo "Frontend URL: ${FRONTEND_URL}"
          fi

      - name: Comment CloudFront URL on commit
        if: env.FRONTEND_URL != ''
        run: |
          set -euo pipefail
          BODY=$(printf "CloudFront URL: %s" "${FRONTEND_URL}")
          curl -sS -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"body\":\"${BODY}\"}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}/comments" >/dev/null
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
